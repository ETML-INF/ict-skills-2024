/**
 * Regional Championship 2024 - Skill 17 - Web Technologies
 * Frontend
 *
 * This file contains the unit tests performed on the frontend task.
 * You may look at the test cases but not modify them.
 *
 * !!! DO NOT EDIT THIS FILE !!!
 */

import { Bishop, King, Knight, Pawn, Queen, Rook } from '../../src/pieces';
import { canPieceMove, move, movePiece } from '../../src/position';

describe('Position', () => {
    describe('movePiece', () => {
        it('moves the correct piece to the target square', () => {
            const piece = new Pawn('e2', 'w');
            const position = [new Pawn('d2', 'w'), piece];
            const newPosition = movePiece(piece, 'e3', position);

            expect(newPosition).to.deep.equal([
                new Pawn('d2', 'w'),
                new Pawn('e3', 'w'),
            ]);
        });

        it('captures an existing piece on the target square', () => {
            const piece = new Rook('h1', 'w');
            const position = [new Pawn('h5', 'b'), piece];
            const newPosition = movePiece(piece, 'h5', position);

            expect(newPosition).to.deep.equal([new Rook('h5', 'w')]);
        });

        it('is immutable and returns a new position', () => {
            const pawn = new Pawn('e2', 'w');
            const originalPosition = [pawn];
            const originalPositionCopy = structuredClone(originalPosition);
            const newPosition = movePiece(pawn, 'e4', originalPosition);

            expect([new Pawn('e4', 'w')]).to.deep.equal(
                newPosition,
                'must return a correct new position'
            );

            expect(originalPosition).not.to.equal(
                newPosition,
                'the array reference must be different'
            );

            expect(originalPosition).to.deep.equal(
                originalPositionCopy,
                'the original array must not have been altered'
            );
        });
    });

    describe('canPieceMove', () => {
        beforeEach(() => {
            cy.viewport(640, 640);
            cy.visit('/cypress/fixtures/page/board.html');
        });

        it('can find the correct pawn to move one forwards', () => {
            const position = [
                new Pawn('d2', 'w'),
                new Pawn('e2', 'w'),
                new Pawn('e4', 'w'),
                new Pawn('c6', 'b'),
                new Pawn('e7', 'b'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                piece: 'P',
                targetSquare: 'e3',
                capture: false,
                check: false,
                checkmate: false,
            };

            // visualize in cypress
            cy.displayPosition(position);
            cy.logMove(instructions);

            cy.then(() => {
                const pieces = position.filter((p) =>
                    canPieceMove(p, instructions, position)
                );
                expect(pieces).to.be.an('array').of.length(1);
                expect(pieces[0].square).to.equal('e2');
            });
        });

        it('can find the correct pawn to move two forwards', () => {
            const position = [
                new Pawn('d3', 'w'),
                new Pawn('e2', 'w'),
                new Pawn('e6', 'w'),
                new Pawn('f2', 'w'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                piece: 'P',
                targetSquare: 'e4',
                capture: false,
                check: false,
                checkmate: false,
            };

            // visualize in cypress
            cy.displayPosition(position);
            cy.logMove(instructions);

            cy.then(() => {
                const pieces = position.filter((p) =>
                    canPieceMove(p, instructions, position)
                );
                expect(pieces).to.be.an('array').of.length(1);
                expect(pieces[0].square).to.equal('e2');
            });
        });

        it('can find the correct pawn to capture with', () => {
            const position = [
                new Pawn('c2', 'w'),
                new Pawn('d2', 'w'),
                new Pawn('e2', 'w'),
                new Knight('d3', 'b'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                piece: 'P',
                fileIdentifier: 'c',
                targetSquare: 'd3',
                capture: true,
                check: false,
                checkmate: false,
            };

            // visualize in cypress
            cy.displayPosition(position);
            cy.logMove(instructions);

            cy.then(() => {
                const pieces = position.filter((p) =>
                    canPieceMove(p, instructions, position)
                );
                expect(pieces).to.be.an('array').of.length(1);
                expect(pieces[0].square).to.equal('c2');
            });
        });

        it('can find the correct rook', () => {
            const position = [
                new King('c3', 'w'),
                new Rook('g8', 'b'),
                new Rook('g2', 'b'),
                new Knight('c6', 'w'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'b',
                piece: 'R',
                rankIdentifier: 8,
                targetSquare: 'c8',
                capture: false,
                check: false,
                checkmate: false,
            };

            // visualize in cypress
            cy.displayPosition(position);
            cy.logMove(instructions);

            cy.then(() => {
                const pieces = position.filter((p) =>
                    canPieceMove(p, instructions, position)
                );
                expect(pieces).to.be.an('array').of.length(1);
                expect(pieces[0].square).to.equal('g8');
            });
        });

        it('can find the correct knight', () => {
            const position = [
                new Knight('c3', 'w'),
                new Knight('e3', 'w'),
                new Pawn('d5', 'b'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                piece: 'N',
                fileIdentifier: 'c',
                targetSquare: 'd5',
                capture: true,
                check: false,
                checkmate: false,
            };

            // visualize in cypress
            cy.displayPosition(position);
            cy.logMove(instructions);

            cy.then(() => {
                const pieces = position.filter((p) =>
                    canPieceMove(p, instructions, position)
                );
                expect(pieces).to.be.an('array').of.length(1);
                expect(pieces[0].square).to.equal('c3');
            });
        });

        it('can find the correct bishop', () => {
            const position = [
                new Bishop('c8', 'b'),
                new Bishop('f8', 'b'),
                new Pawn('d6', 'w'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'b',
                piece: 'B',
                targetSquare: 'd6',
                capture: true,
                check: false,
                checkmate: false,
            };

            // visualize in cypress
            cy.displayPosition(position);
            cy.logMove(instructions);

            cy.then(() => {
                const pieces = position.filter((p) =>
                    canPieceMove(p, instructions, position)
                );
                expect(pieces).to.be.an('array').of.length(1);
                expect(pieces[0].square).to.equal('f8');
            });
        });

        it('can find the correct queen', () => {
            const position = [
                new King('c8', 'b'),
                new Queen('h1', 'w'),
                new King('b2', 'w'),
                new Queen('h4', 'w'),
                new Queen('e4', 'w'),
                new Pawn('e1', 'b'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                piece: 'Q',
                fileIdentifier: 'h',
                rankIdentifier: 4,
                targetSquare: 'e1',
                capture: false,
                check: false,
                checkmate: false,
            };

            // visualize in cypress
            cy.displayPosition(position);
            cy.logMove(instructions);

            cy.then(() => {
                const pieces = position.filter((p) =>
                    canPieceMove(p, instructions, position)
                );
                expect(pieces).to.be.an('array').of.length(1);
                expect(pieces[0].square).to.equal('h4');
            });
        });

        it('can find the correct king', () => {
            const position = [new King('e8', 'b'), new King('e1', 'w')];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                piece: 'K',
                targetSquare: 'e2',
                capture: false,
                check: false,
                checkmate: false,
            };

            // visualize in cypress
            cy.displayPosition(position);
            cy.logMove(instructions);

            cy.then(() => {
                const pieces = position.filter((p) =>
                    canPieceMove(p, instructions, position)
                );
                expect(pieces).to.be.an('array').of.length(1);
                expect(pieces[0].square).to.equal('e1');
            });
        });
    });

    describe('move', () => {
        beforeEach(() => {
            cy.viewport(640, 640);
            cy.visit('/cypress/fixtures/page/board.html');
        });

        it('can capture with the correct pawn', () => {
            const originalPosition = [
                new Pawn('c3', 'w'),
                new Pawn('d3', 'w'),
                new Pawn('d4', 'b'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                piece: 'P',
                fileIdentifier: 'c',
                targetSquare: 'd4',
                capture: true,
                check: false,
                checkmate: false,
            };

            const newPosition = move(instructions, originalPosition);

            // visualize in cypress
            cy.displayPosition(originalPosition);
            cy.logMove(instructions);
            cy.displayPosition(newPosition);

            cy.then(() => {
                expect(newPosition).to.have.deep.members([
                    new Pawn('d3', 'w'),
                    new Pawn('d4', 'w'),
                ]);
            });
        });

        it('can move the correct, unobstructed pawn forwards', () => {
            const originalPosition = [new Pawn('e2', 'w'), new Pawn('e3', 'w')];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                piece: 'P',
                targetSquare: 'e4',
                capture: false,
                check: false,
                checkmate: false,
            };

            const newPosition = move(instructions, originalPosition);

            // visualize in cypress
            cy.displayPosition(originalPosition);
            cy.logMove(instructions);
            cy.displayPosition(newPosition);

            cy.then(() =>
                expect(newPosition).to.have.deep.members([
                    new Pawn('e2', 'w'),
                    new Pawn('e4', 'w'),
                ])
            );
        });

        it('can capture with the correct, unobstructed rook', () => {
            const originalPosition = [
                new Rook('g7', 'b'),
                new King('g6', 'b'),
                new Rook('g3', 'b'),
                new Pawn('g5', 'w'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'b',
                piece: 'R',
                targetSquare: 'g5',
                capture: true,
                check: false,
                checkmate: false,
            };

            const newPosition = move(instructions, originalPosition);

            // visualize in cypress
            cy.displayPosition(originalPosition);
            cy.logMove(instructions);
            cy.displayPosition(newPosition);

            cy.then(() =>
                expect(newPosition).to.have.deep.members([
                    new Rook('g7', 'b'),
                    new King('g6', 'b'),
                    new Rook('g5', 'b'),
                ])
            );
        });

        it('can capture with the correct, unobstructed queen', () => {
            const originalPosition = [
                new Queen('h5', 'b'),
                new Knight('e5', 'w'),
                new Queen('b2', 'b'),
                new Pawn('f5', 'w'),
            ];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'b',
                piece: 'Q',
                targetSquare: 'e5',
                capture: true,
                check: false,
                checkmate: false,
            };

            const newPosition = move(instructions, originalPosition);

            // visualize in cypress
            cy.displayPosition(originalPosition);
            cy.logMove(instructions);
            cy.displayPosition(newPosition);

            cy.then(() =>
                expect(newPosition).to.have.deep.members([
                    new Queen('h5', 'b'),
                    new Queen('e5', 'b'),
                    new Pawn('f5', 'w'),
                ])
            );
        });

        it('can castle short', () => {
            const originalPosition = [new King('e1', 'w'), new Rook('h1', 'w')];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'w',
                castle: 'short',
            };

            const newPosition = move(instructions, originalPosition);

            // visualize in cypress
            cy.displayPosition(originalPosition);
            cy.logMove(instructions);
            cy.displayPosition(newPosition);

            cy.then(() =>
                expect(newPosition).to.have.deep.members([
                    new King('g1', 'w'),
                    new Rook('f1', 'w'),
                ])
            );
        });

        it('can castle long', () => {
            const originalPosition = [new King('e8', 'b'), new Rook('a8', 'b')];

            /** @type {import('../../src/util').Move} */
            const instructions = {
                num: 1,
                color: 'b',
                castle: 'long',
            };

            const newPosition = move(instructions, originalPosition);

            // visualize in cypress
            cy.displayPosition(originalPosition);
            cy.logMove(instructions);
            cy.displayPosition(newPosition);

            cy.then(() =>
                expect(newPosition).to.have.deep.members([
                    new King('c8', 'b'),
                    new Rook('d8', 'b'),
                ])
            );
        });
    });
});
