"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Strategy = _interopRequireDefault(require("./Strategy"));

var _Test = _interopRequireDefault(require("./Test"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Group {
  extraTests = {};
  tests = {};
  overrides = [];

  constructor(match, defaultPoints, strategy, displayName, maxPoints) {
    this.match = match;
    this.defaultPoints = defaultPoints;
    this.strategy = strategy;
    this.displayName = displayName;
    this.maxPoints = maxPoints;
    this.pattern = new RegExp(`^${match}$`);
  }
  /**
   * Add a new normal test to this group
   *
   * @param name Test name
   * @param successful Whether the test was successful or not
   */


  addNormalTest(name, successful) {
    if (this.tests[name]) {
      throw new Error(`A test with the same name already exists in the same group. Test name: ${name}`);
    }

    const override = this.getOverrideForTest(name);
    this.tests[name] = new _Test.default(name, override?.getPoints() || this.defaultPoints, successful, override?.isRequired() || false); // if an extra tests exist and that failed while this normal test succeeded,
    // require a manual check

    if (typeof this.extraTests[name] !== 'undefined' && successful && !this.extraTests[name]) {
      this.tests[name].setManualCheck(true);
    }
  }
  /**
   * Add a new extra test to this group
   *
   * @param name Test name
   * @param successful Whether the test was successful or not
   */


  addExtraTest(name, successful) {
    if (this.extraTests[name]) {
      throw new Error(`An extra test with the same name already exists in the same group. Test name: ${name}`);
    }

    this.extraTests[name] = successful; // if the normal test succeeded while this extra test failed, require a manual check

    if (this.tests[name] && this.tests[name].isSuccessful() && !successful) {
      this.tests[name].setManualCheck(true);
    }
  }
  /**
   * Get the override for a specific test if it exists
   *
   * @param name Test name
   */


  getOverrideForTest(name) {
    return this.overrides.find(override => override.matches(name));
  }
  /**
   * Rounds points up to two decimal places
   *
   * @param points Points
   * @returns
   */
  // eslint-disable-next-line class-methods-use-this


  roundPoints(points) {
    return +points.toFixed(2);
  }
  /**
   * Check if a test matches this group
   *
   * @param match Test name to check
   */


  matches(match) {
    return this.pattern.test(match);
  }
  /**
   * Add a new test to this group
   *
   * @param name Test name
   * @param extra Whether it is an extra test or not
   * @param successful Whether the test was successful or not
   */


  addTest(name, extra, successful) {
    if (extra) {
      this.addExtraTest(name, successful);
    } else {
      this.addNormalTest(name, successful);
    }
  }
  /**
   * Add a new test override
   *
   * @param override Test override
   */


  addOverride(override) {
    this.overrides.push(override);
  }
  /**
   * Calculates the scored points
   */


  getPoints() {
    let requiredTestFailed = false;
    const points = this.getTests().reduce((prev, current) => {
      if (current.isRequired() && !current.isSuccessful()) {
        requiredTestFailed = true;
      }

      if (this.strategy === _Strategy.default.Add) {
        return prev + current.getPoints();
      }

      if (current.isSuccessful()) {
        return prev;
      }

      return prev - current.getMaxPoints();
    }, this.strategy === _Strategy.default.Deduct ? this.getMaxPoints() : 0);
    return requiredTestFailed ? 0 : this.roundPoints(Math.max(points, 0));
  }
  /**
   * Calculates the maximum possible points
   */


  getMaxPoints() {
    // respect the optional maxPoints value for the deduct strategy
    if (this.strategy === _Strategy.default.Deduct && typeof this.maxPoints !== 'undefined') {
      return this.maxPoints;
    } // add all possible points for the tests in this group


    return this.roundPoints(this.getTests().reduce((prev, current) => prev + current.getMaxPoints(), 0));
  }
  /**
   * Returns the tests that do not have an extra test
   */


  getMissingExtraTests() {
    return Object.keys(this.tests).filter(testName => typeof this.extraTests[testName] === 'undefined').map(testName => this.tests[testName]);
  }
  /**
   * Returns the name of extra tests that do not have a normal test
   */


  getMissingNormalTests() {
    return Object.keys(this.extraTests).filter(testName => typeof this.tests[testName] === 'undefined');
  }
  /**
   * Returns whether this group has at least one normal or extra test
   */


  hasTests() {
    return Object.keys(this.tests).length > 0 || Object.keys(this.extraTests).length > 0;
  }

  getDefaultPoints() {
    return this.defaultPoints;
  }

  getStrategy() {
    return this.strategy;
  }

  getDisplayName() {
    return this.displayName ?? this.match;
  }

  getTests() {
    return Object.values(this.tests);
  }

  getPattern() {
    return this.match;
  }

  requiresManualCheck() {
    return !!this.getTests().find(test => test.requiresManualCheck());
  }

  toJSON() {
    return {
      group: this.getDisplayName(),
      points: this.getPoints(),
      maxPoints: this.getMaxPoints(),
      strategy: this.getStrategy(),
      manualCheck: this.requiresManualCheck(),
      tests: this.getTests()
    };
  }

}

exports.default = Group;