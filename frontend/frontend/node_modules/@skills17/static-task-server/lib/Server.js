"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _express = _interopRequireDefault(require("express"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Server {
  constructor(config) {
    this.config = config;
  }
  /**
   * Checks whether the server is bound to localhost only
   */


  isLocalhost() {
    const serveConfig = this.config.getServe();
    return !serveConfig.bind || serveConfig.bind === '127.0.0.1';
  }
  /**
   * Returns the host under which the server is available
   */


  getHost() {
    const serveConfig = this.config.getServe();
    return `http://${this.isLocalhost() ? 'localhost' : serveConfig.bind}:${serveConfig.port}`;
  }
  /**
   * Starts serving static task files
   *
   * @param printOnReady Print to the console on which address the files are served
   * @param printer Printer function
   */


  async serve(printOnReady = true, printer = console.log) {
    return new Promise(resolve => {
      const serveConfig = this.config.getServe();

      if (!serveConfig.enabled) {
        resolve();
        return;
      }

      const app = (0, _express.default)(); // create mappings

      const mappings = serveConfig.mapping;
      const projectRoot = this.config.getProjectRoot();
      Object.keys(mappings).forEach(httpPath => {
        const filePath = mappings[httpPath];
        app.use(httpPath, _express.default.static(_path.default.resolve(projectRoot, filePath)));
      }); // handle listening callback

      const onListen = () => {
        if (printOnReady) {
          printer(`Task available at ${this.getHost()}`);
        }

        resolve();
      }; // start listening


      if (serveConfig.bind) {
        this.server = app.listen(serveConfig.port, serveConfig.bind, onListen);
      } else {
        this.server = app.listen(serveConfig.port, onListen);
      }
    });
  }
  /**
   * Stops serving files
   */


  async stop() {
    return new Promise(resolve => {
      if (this.server) {
        this.server.close(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

}

exports.default = Server;