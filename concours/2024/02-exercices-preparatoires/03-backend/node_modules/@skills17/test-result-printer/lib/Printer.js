"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chalk = require("chalk");

var _figures = require("figures");

class Printer {
  constructor(run) {
    this.run = run;
  }
  /**
   * Prints the test run to the console in a nice format.
   */


  print({
    printer = console.log,
    printHeader = true,
    printFooter = true,
    printPoints = true
  } = {}) {
    // print header
    if (printHeader) {
      printer((0, _chalk.bgGreen)((0, _chalk.black)('------------       RESULT       ------------')));
      printer('\nSummary:');
    } // print groups


    this.run.getGroups().forEach(group => {
      // skip groups without any test
      if (group.getTests().length === 0) {
        return;
      }

      const points = group.getPoints();
      const maxPoints = group.getMaxPoints();
      const groupName = (0, _chalk.bold)((0, _chalk.underline)(group.getDisplayName()));
      const pointsText = `${points}/${maxPoints} point${maxPoints !== 1 ? 's' : ''}`;
      const pointsColor = this.getPointsColor(points, maxPoints);
      let manualCheck = '';

      if (group.requiresManualCheck()) {
        manualCheck = (0, _chalk.bold)((0, _chalk.yellow)(' [manual check required]'));
      }

      if (printPoints) {
        printer(`  ${groupName}${(0, _chalk.blue)(':')} ${pointsColor(pointsText)}${manualCheck}`);
      } else {
        printer(`  ${groupName}${manualCheck}`);
      } // print all tests of this group


      group.getTests().forEach(test => {
        let resultText = '';
        let resultColor = _chalk.green;
        let resultSymbol = _figures.tick;

        if (test.requiresManualCheck()) {
          resultText = ' please check manually for static return values and/or logical errors';
          resultColor = _chalk.yellow;
          resultSymbol = '?';
        } else if (!test.isSuccessful()) {
          resultColor = _chalk.red;
          resultSymbol = _figures.cross;
        }

        const symbol = (0, _chalk.bold)(resultColor(resultSymbol));
        printer(`    ${symbol} ${test.getName()}${resultColor(resultText)}`);
      });
    }); // print footer

    if (printFooter) {
      if (printPoints) {
        this.printTotal(printer);
      }

      printer(`\n${(0, _chalk.blue)('Info:')}`, 'The detailed test and error information is visible above the result summary.');
    }

    this.printWarnings(printer);
    printer();
  }

  getPointsColor(points, maxPoints) {
    if (points > 0) {
      return points === maxPoints ? _chalk.green : _chalk.yellow;
    }

    return _chalk.red;
  }

  printTotal(printer) {
    const totalPoints = this.run.getGroups().reduce((groupPoints, group) => groupPoints + group.getPoints(), 0);
    const totalMaxPoints = this.run.getGroups().reduce((groupPoints, group) => groupPoints + group.getMaxPoints(), 0);
    const totalPointsRounded = Math.round(totalPoints * 100) / 100;
    const totalMaxPointsRounded = Math.round(totalMaxPoints * 100) / 100;
    const totalPointsColor = this.getPointsColor(totalPoints, totalMaxPoints);
    printer(`\nTotal: ${totalPointsColor(`${totalPointsRounded}/${totalMaxPointsRounded} point${totalMaxPointsRounded !== 1 ? 's' : ''}`)}`);
  }

  printWarnings(printer) {
    // search for groups without tests
    const emptyGroups = this.run.getGroups().filter(group => !group.hasTests()).map(group => group.getDisplayName());

    if (this.run.hasExtraTest() && emptyGroups.length > 0) {
      this.printTestWarning('The following groups do not have any test:', emptyGroups, printer);
    } // search for tests that do not have extra tests


    const missingExtraTests = this.run.getGroups().map(group => group.getMissingExtraTests().map(test => `${group.getDisplayName()} > ${test.getName()}`)).filter(tests => tests.length > 0);

    if (this.run.hasExtraTest() && missingExtraTests.length > 0) {
      this.printTestWarning('The following tests do NOT have extra tests and so can NOT be checked for possible cheating:', missingExtraTests.flat(), printer);
    } // search for extra tests that do not have a normal test


    const missingNormalTests = this.run.getGroups().map(group => group.getMissingNormalTests().map(test => `${group.getDisplayName()} > ${test}`)).filter(tests => tests.length > 0);

    if (missingNormalTests.length > 0) {
      this.printTestWarning('The following extra tests do not belong to a main test and were ignored:', missingNormalTests.flat(), printer);
    } // search for tests that do not belong to any group


    if (this.run.getUngroupedTests().length > 0) {
      this.printTestWarning('The following tests do not belong to a group and were ignored:', this.run.getUngroupedTests(), printer);
    }
  }

  printTestWarning(warning, tests, printer) {
    printer();
    printer((0, _chalk.yellow)('WARNING:', warning));
    tests.forEach(test => {
      printer(`  - ${test}`);
    });
  }

}

exports.default = Printer;